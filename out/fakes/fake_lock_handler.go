// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/concourse/pool-resource/out"
)

type FakeLockHandler struct {
	GrabAvailableLockStub        func() (lock string, version string, err error)
	grabAvailableLockMutex       sync.RWMutex
	grabAvailableLockArgsForCall []struct{}
	grabAvailableLockReturns     struct {
		result1 string
		result2 string
		result3 error
	}
	grabAvailableLockReturnsOnCall map[int]struct {
		result1 string
		result2 string
		result3 error
	}
	UnclaimLockStub        func(lock string) (version string, err error)
	unclaimLockMutex       sync.RWMutex
	unclaimLockArgsForCall []struct {
		lock string
	}
	unclaimLockReturns struct {
		result1 string
		result2 error
	}
	unclaimLockReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	AddLockStub        func(lock string, contents []byte, initiallyClaimed bool) (version string, err error)
	addLockMutex       sync.RWMutex
	addLockArgsForCall []struct {
		lock             string
		contents         []byte
		initiallyClaimed bool
	}
	addLockReturns struct {
		result1 string
		result2 error
	}
	addLockReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	RemoveLockStub        func(lock string) (version string, err error)
	removeLockMutex       sync.RWMutex
	removeLockArgsForCall []struct {
		lock string
	}
	removeLockReturns struct {
		result1 string
		result2 error
	}
	removeLockReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ClaimLockStub        func(lock string) (version string, err error)
	claimLockMutex       sync.RWMutex
	claimLockArgsForCall []struct {
		lock string
	}
	claimLockReturns struct {
		result1 string
		result2 error
	}
	claimLockReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	UpdateLockStub        func(lock string, contents []byte) (version string, err error)
	updateLockMutex       sync.RWMutex
	updateLockArgsForCall []struct {
		lock     string
		contents []byte
	}
	updateLockReturns struct {
		result1 string
		result2 error
	}
	updateLockReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SetupStub        func() error
	setupMutex       sync.RWMutex
	setupArgsForCall []struct{}
	setupReturns     struct {
		result1 error
	}
	setupReturnsOnCall map[int]struct {
		result1 error
	}
	BroadcastLockPoolStub        func() ([]byte, error)
	broadcastLockPoolMutex       sync.RWMutex
	broadcastLockPoolArgsForCall []struct{}
	broadcastLockPoolReturns     struct {
		result1 []byte
		result2 error
	}
	broadcastLockPoolReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ResetLockStub        func() error
	resetLockMutex       sync.RWMutex
	resetLockArgsForCall []struct{}
	resetLockReturns     struct {
		result1 error
	}
	resetLockReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeLockHandler) GrabAvailableLock() (lock string, version string, err error) {
	fake.grabAvailableLockMutex.Lock()
	ret, specificReturn := fake.grabAvailableLockReturnsOnCall[len(fake.grabAvailableLockArgsForCall)]
	fake.grabAvailableLockArgsForCall = append(fake.grabAvailableLockArgsForCall, struct{}{})
	fake.recordInvocation("GrabAvailableLock", []interface{}{})
	fake.grabAvailableLockMutex.Unlock()
	if fake.GrabAvailableLockStub != nil {
		return fake.GrabAvailableLockStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.grabAvailableLockReturns.result1, fake.grabAvailableLockReturns.result2, fake.grabAvailableLockReturns.result3
}

func (fake *FakeLockHandler) GrabAvailableLockCallCount() int {
	fake.grabAvailableLockMutex.RLock()
	defer fake.grabAvailableLockMutex.RUnlock()
	return len(fake.grabAvailableLockArgsForCall)
}

func (fake *FakeLockHandler) GrabAvailableLockReturns(result1 string, result2 string, result3 error) {
	fake.GrabAvailableLockStub = nil
	fake.grabAvailableLockReturns = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeLockHandler) GrabAvailableLockReturnsOnCall(i int, result1 string, result2 string, result3 error) {
	fake.GrabAvailableLockStub = nil
	if fake.grabAvailableLockReturnsOnCall == nil {
		fake.grabAvailableLockReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
			result3 error
		})
	}
	fake.grabAvailableLockReturnsOnCall[i] = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeLockHandler) UnclaimLock(lock string) (version string, err error) {
	fake.unclaimLockMutex.Lock()
	ret, specificReturn := fake.unclaimLockReturnsOnCall[len(fake.unclaimLockArgsForCall)]
	fake.unclaimLockArgsForCall = append(fake.unclaimLockArgsForCall, struct {
		lock string
	}{lock})
	fake.recordInvocation("UnclaimLock", []interface{}{lock})
	fake.unclaimLockMutex.Unlock()
	if fake.UnclaimLockStub != nil {
		return fake.UnclaimLockStub(lock)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.unclaimLockReturns.result1, fake.unclaimLockReturns.result2
}

func (fake *FakeLockHandler) UnclaimLockCallCount() int {
	fake.unclaimLockMutex.RLock()
	defer fake.unclaimLockMutex.RUnlock()
	return len(fake.unclaimLockArgsForCall)
}

func (fake *FakeLockHandler) UnclaimLockArgsForCall(i int) string {
	fake.unclaimLockMutex.RLock()
	defer fake.unclaimLockMutex.RUnlock()
	return fake.unclaimLockArgsForCall[i].lock
}

func (fake *FakeLockHandler) UnclaimLockReturns(result1 string, result2 error) {
	fake.UnclaimLockStub = nil
	fake.unclaimLockReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeLockHandler) UnclaimLockReturnsOnCall(i int, result1 string, result2 error) {
	fake.UnclaimLockStub = nil
	if fake.unclaimLockReturnsOnCall == nil {
		fake.unclaimLockReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.unclaimLockReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeLockHandler) AddLock(lock string, contents []byte, initiallyClaimed bool) (version string, err error) {
	var contentsCopy []byte
	if contents != nil {
		contentsCopy = make([]byte, len(contents))
		copy(contentsCopy, contents)
	}
	fake.addLockMutex.Lock()
	ret, specificReturn := fake.addLockReturnsOnCall[len(fake.addLockArgsForCall)]
	fake.addLockArgsForCall = append(fake.addLockArgsForCall, struct {
		lock             string
		contents         []byte
		initiallyClaimed bool
	}{lock, contentsCopy, initiallyClaimed})
	fake.recordInvocation("AddLock", []interface{}{lock, contentsCopy, initiallyClaimed})
	fake.addLockMutex.Unlock()
	if fake.AddLockStub != nil {
		return fake.AddLockStub(lock, contents, initiallyClaimed)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.addLockReturns.result1, fake.addLockReturns.result2
}

func (fake *FakeLockHandler) AddLockCallCount() int {
	fake.addLockMutex.RLock()
	defer fake.addLockMutex.RUnlock()
	return len(fake.addLockArgsForCall)
}

func (fake *FakeLockHandler) AddLockArgsForCall(i int) (string, []byte, bool) {
	fake.addLockMutex.RLock()
	defer fake.addLockMutex.RUnlock()
	return fake.addLockArgsForCall[i].lock, fake.addLockArgsForCall[i].contents, fake.addLockArgsForCall[i].initiallyClaimed
}

func (fake *FakeLockHandler) AddLockReturns(result1 string, result2 error) {
	fake.AddLockStub = nil
	fake.addLockReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeLockHandler) AddLockReturnsOnCall(i int, result1 string, result2 error) {
	fake.AddLockStub = nil
	if fake.addLockReturnsOnCall == nil {
		fake.addLockReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.addLockReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeLockHandler) RemoveLock(lock string) (version string, err error) {
	fake.removeLockMutex.Lock()
	ret, specificReturn := fake.removeLockReturnsOnCall[len(fake.removeLockArgsForCall)]
	fake.removeLockArgsForCall = append(fake.removeLockArgsForCall, struct {
		lock string
	}{lock})
	fake.recordInvocation("RemoveLock", []interface{}{lock})
	fake.removeLockMutex.Unlock()
	if fake.RemoveLockStub != nil {
		return fake.RemoveLockStub(lock)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.removeLockReturns.result1, fake.removeLockReturns.result2
}

func (fake *FakeLockHandler) RemoveLockCallCount() int {
	fake.removeLockMutex.RLock()
	defer fake.removeLockMutex.RUnlock()
	return len(fake.removeLockArgsForCall)
}

func (fake *FakeLockHandler) RemoveLockArgsForCall(i int) string {
	fake.removeLockMutex.RLock()
	defer fake.removeLockMutex.RUnlock()
	return fake.removeLockArgsForCall[i].lock
}

func (fake *FakeLockHandler) RemoveLockReturns(result1 string, result2 error) {
	fake.RemoveLockStub = nil
	fake.removeLockReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeLockHandler) RemoveLockReturnsOnCall(i int, result1 string, result2 error) {
	fake.RemoveLockStub = nil
	if fake.removeLockReturnsOnCall == nil {
		fake.removeLockReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.removeLockReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeLockHandler) ClaimLock(lock string) (version string, err error) {
	fake.claimLockMutex.Lock()
	ret, specificReturn := fake.claimLockReturnsOnCall[len(fake.claimLockArgsForCall)]
	fake.claimLockArgsForCall = append(fake.claimLockArgsForCall, struct {
		lock string
	}{lock})
	fake.recordInvocation("ClaimLock", []interface{}{lock})
	fake.claimLockMutex.Unlock()
	if fake.ClaimLockStub != nil {
		return fake.ClaimLockStub(lock)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.claimLockReturns.result1, fake.claimLockReturns.result2
}

func (fake *FakeLockHandler) ClaimLockCallCount() int {
	fake.claimLockMutex.RLock()
	defer fake.claimLockMutex.RUnlock()
	return len(fake.claimLockArgsForCall)
}

func (fake *FakeLockHandler) ClaimLockArgsForCall(i int) string {
	fake.claimLockMutex.RLock()
	defer fake.claimLockMutex.RUnlock()
	return fake.claimLockArgsForCall[i].lock
}

func (fake *FakeLockHandler) ClaimLockReturns(result1 string, result2 error) {
	fake.ClaimLockStub = nil
	fake.claimLockReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeLockHandler) ClaimLockReturnsOnCall(i int, result1 string, result2 error) {
	fake.ClaimLockStub = nil
	if fake.claimLockReturnsOnCall == nil {
		fake.claimLockReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.claimLockReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeLockHandler) UpdateLock(lock string, contents []byte) (version string, err error) {
	var contentsCopy []byte
	if contents != nil {
		contentsCopy = make([]byte, len(contents))
		copy(contentsCopy, contents)
	}
	fake.updateLockMutex.Lock()
	ret, specificReturn := fake.updateLockReturnsOnCall[len(fake.updateLockArgsForCall)]
	fake.updateLockArgsForCall = append(fake.updateLockArgsForCall, struct {
		lock     string
		contents []byte
	}{lock, contentsCopy})
	fake.recordInvocation("UpdateLock", []interface{}{lock, contentsCopy})
	fake.updateLockMutex.Unlock()
	if fake.UpdateLockStub != nil {
		return fake.UpdateLockStub(lock, contents)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateLockReturns.result1, fake.updateLockReturns.result2
}

func (fake *FakeLockHandler) UpdateLockCallCount() int {
	fake.updateLockMutex.RLock()
	defer fake.updateLockMutex.RUnlock()
	return len(fake.updateLockArgsForCall)
}

func (fake *FakeLockHandler) UpdateLockArgsForCall(i int) (string, []byte) {
	fake.updateLockMutex.RLock()
	defer fake.updateLockMutex.RUnlock()
	return fake.updateLockArgsForCall[i].lock, fake.updateLockArgsForCall[i].contents
}

func (fake *FakeLockHandler) UpdateLockReturns(result1 string, result2 error) {
	fake.UpdateLockStub = nil
	fake.updateLockReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeLockHandler) UpdateLockReturnsOnCall(i int, result1 string, result2 error) {
	fake.UpdateLockStub = nil
	if fake.updateLockReturnsOnCall == nil {
		fake.updateLockReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.updateLockReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeLockHandler) Setup() error {
	fake.setupMutex.Lock()
	ret, specificReturn := fake.setupReturnsOnCall[len(fake.setupArgsForCall)]
	fake.setupArgsForCall = append(fake.setupArgsForCall, struct{}{})
	fake.recordInvocation("Setup", []interface{}{})
	fake.setupMutex.Unlock()
	if fake.SetupStub != nil {
		return fake.SetupStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setupReturns.result1
}

func (fake *FakeLockHandler) SetupCallCount() int {
	fake.setupMutex.RLock()
	defer fake.setupMutex.RUnlock()
	return len(fake.setupArgsForCall)
}

func (fake *FakeLockHandler) SetupReturns(result1 error) {
	fake.SetupStub = nil
	fake.setupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLockHandler) SetupReturnsOnCall(i int, result1 error) {
	fake.SetupStub = nil
	if fake.setupReturnsOnCall == nil {
		fake.setupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLockHandler) BroadcastLockPool() ([]byte, error) {
	fake.broadcastLockPoolMutex.Lock()
	ret, specificReturn := fake.broadcastLockPoolReturnsOnCall[len(fake.broadcastLockPoolArgsForCall)]
	fake.broadcastLockPoolArgsForCall = append(fake.broadcastLockPoolArgsForCall, struct{}{})
	fake.recordInvocation("BroadcastLockPool", []interface{}{})
	fake.broadcastLockPoolMutex.Unlock()
	if fake.BroadcastLockPoolStub != nil {
		return fake.BroadcastLockPoolStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.broadcastLockPoolReturns.result1, fake.broadcastLockPoolReturns.result2
}

func (fake *FakeLockHandler) BroadcastLockPoolCallCount() int {
	fake.broadcastLockPoolMutex.RLock()
	defer fake.broadcastLockPoolMutex.RUnlock()
	return len(fake.broadcastLockPoolArgsForCall)
}

func (fake *FakeLockHandler) BroadcastLockPoolReturns(result1 []byte, result2 error) {
	fake.BroadcastLockPoolStub = nil
	fake.broadcastLockPoolReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeLockHandler) BroadcastLockPoolReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.BroadcastLockPoolStub = nil
	if fake.broadcastLockPoolReturnsOnCall == nil {
		fake.broadcastLockPoolReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.broadcastLockPoolReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeLockHandler) ResetLock() error {
	fake.resetLockMutex.Lock()
	ret, specificReturn := fake.resetLockReturnsOnCall[len(fake.resetLockArgsForCall)]
	fake.resetLockArgsForCall = append(fake.resetLockArgsForCall, struct{}{})
	fake.recordInvocation("ResetLock", []interface{}{})
	fake.resetLockMutex.Unlock()
	if fake.ResetLockStub != nil {
		return fake.ResetLockStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.resetLockReturns.result1
}

func (fake *FakeLockHandler) ResetLockCallCount() int {
	fake.resetLockMutex.RLock()
	defer fake.resetLockMutex.RUnlock()
	return len(fake.resetLockArgsForCall)
}

func (fake *FakeLockHandler) ResetLockReturns(result1 error) {
	fake.ResetLockStub = nil
	fake.resetLockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLockHandler) ResetLockReturnsOnCall(i int, result1 error) {
	fake.ResetLockStub = nil
	if fake.resetLockReturnsOnCall == nil {
		fake.resetLockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resetLockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLockHandler) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.grabAvailableLockMutex.RLock()
	defer fake.grabAvailableLockMutex.RUnlock()
	fake.unclaimLockMutex.RLock()
	defer fake.unclaimLockMutex.RUnlock()
	fake.addLockMutex.RLock()
	defer fake.addLockMutex.RUnlock()
	fake.removeLockMutex.RLock()
	defer fake.removeLockMutex.RUnlock()
	fake.claimLockMutex.RLock()
	defer fake.claimLockMutex.RUnlock()
	fake.updateLockMutex.RLock()
	defer fake.updateLockMutex.RUnlock()
	fake.setupMutex.RLock()
	defer fake.setupMutex.RUnlock()
	fake.broadcastLockPoolMutex.RLock()
	defer fake.broadcastLockPoolMutex.RUnlock()
	fake.resetLockMutex.RLock()
	defer fake.resetLockMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeLockHandler) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ out.LockHandler = new(FakeLockHandler)
